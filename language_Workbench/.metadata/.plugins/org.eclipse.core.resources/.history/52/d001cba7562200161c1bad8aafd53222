package org.irisa.diverse.videogen.videoGen.aspects.visitors

import org.irisa.diverse.videogen.transformations.helpers.VideoGenHelper
import org.irisa.diverse.videogen.videoGen.Alternatives
import org.irisa.diverse.videogen.videoGen.Optional
import org.irisa.diverse.videogen.videoGen.Sequence
import org.irisa.diverse.videogen.videoGen.VideoGen
import fr.inria.diverse.k3.al.annotationprocessor.Aspect

class VideoGenVariantsVisitor {
	
	public int variants
		
	def VideoGenVariantsVisitor visit(VideoGen vid) {
		variants = 1
		println("VideoGen Variants Visitor started...")
		VideoGenHelper.allSequences(vid).forEach[visit]
		this
	}
	
	def private visit(Sequence seq) {
		if (seq.active) {
			println("VideoGen Variants Visitor : " + seq)
			if (seq instanceof Optional) {
				seq.visit
			} else if (seq instanceof Alternatives) {
				seq.visit
			}
			println("VideoGen Variants Visitor : " + variants)
		}
	}
		
	def private visit(Alternatives alt) {
		variants *= alt.options.filter[active].size
	}
	
	def private visit(Optional opt) {
		variants *= 2
	}
}

@Aspect(className=VideoGen)
class VideoGenVariantsAspect {
	
	public int variants
    
	def void findVariants() {
		_self.variants = 1
		println("VideoGen Variants Visitor started...")
		// Call the visitor
		_self.transitions.filter[it instanceof Sequence]
			.map[it as Sequence]
			.forEach[findVariants(_self)]
		this
	}
}

@Aspect(className=Sequence)
class SequenceVariantsAspect {

	def void findVariants(VideoGen vid) {
		if (_self.active) {
			println("VideoGen Variants Visitor : " + _self)
			if (_self instanceof Optional) {
				_self.findVariants
			} else if (_self instanceof Alternatives) {
				_self.findVariants
			}
			println("VideoGen Variants Visitor : " + vid.variants)
		}
	}
}	
@Aspect(className=Alternatives)
class AlternativesDurationConstraintsAspect {
	
	def void configureUserConstraints(VideoGen vid) {
		val optionsSize = _self.options.size
		val localVars = newArrayOfSize(optionsSize)
		var localCount = 0
		for (Optional opt: _self.options) {
			val ft = opt.configureUserConstraints(vid)
			localVars.set(localCount, ft)
			localCount++
		}
		
		// Create the clause
		val logOp = _self.createAlternativesXorClause(localVars)
		SatFactory.addClauses(logOp, vid.solver)
	}
	
	def void applyUserConstraints(VideoGen vid) {
		_self.options.forEach[applyUserConstraints(vid)]
	}
	
	/*
	 * Constructs the Xor constraints fro man Alternative
	 * 
	 * Result is :
	 * 		logOp = LogOp.xor(lastVar,
	 *			LogOp.xor(...
	 *				LogOp.xor(firstVar, secondVar)))
	 */
	def private LogOp createAlternativesXorClause(IntVar[] vars) {
		var LogOp logOp = null
		var BoolVar firstVar = vars.head  as BoolVar
		// Browse except the first element

		for (IntVar boolVar: vars.tail) {
			if (logOp == null) {
				logOp = LogOp.xor(firstVar, boolVar as BoolVar)
			} else {
				logOp = LogOp.xor(boolVar as BoolVar, logOp)
			}
		}
		logOp
	}
}

@Aspect(className=Optional)
class OptionalDurationConstraintsAspect {
	
	def IntVar configureUserConstraints(VideoGen vid) {
		// For choco, a bool is a integer between 0 and 1
		var IntVar ft
		if (_self.active) {	
			if (_self.selected) {
				ft = VariableFactory.fixed(_self.name, 1, vid.solver)
			} else {
				ft = VariableFactory.bool(_self.name, vid.solver)
			}
		} else {
			ft = VariableFactory.fixed(_self.name, 0, vid.solver)
		}
		vid.addVar(ft, _self.video.duration)
		ft
	}
	
	def void applyUserConstraints(VideoGen vid) {
		if (vid.variables.filter[value == 0].exists[name == _self.name]) {
			_self.active = false
		}
	}
}