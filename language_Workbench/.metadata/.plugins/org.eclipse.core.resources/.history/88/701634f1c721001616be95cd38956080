package org.irisa.diverse.videogen.videoGen.aspects.visitors

import org.chocosolver.solver.Solver
import org.chocosolver.solver.constraints.IntConstraintFactory
import org.chocosolver.solver.trace.Chatterbox
import org.chocosolver.solver.variables.IntVar
import org.chocosolver.solver.variables.VariableFactory
import org.irisa.diverse.videogen.videoGen.Alternatives
import org.irisa.diverse.videogen.videoGen.Mandatory
import org.irisa.diverse.videogen.videoGen.Optional
import org.irisa.diverse.videogen.videoGen.Sequence
import org.irisa.diverse.videogen.videoGen.VideoGen
import org.irisa.diverse.videogen.videoGen.aspects.utils.LoggableVisitor
import org.chocosolver.solver.constraints.SatFactory
import org.chocosolver.solver.ResolutionPolicy
import org.chocosolver.solver.constraints.nary.cnf.LogOp
import org.chocosolver.solver.variables.BoolVar
import fr.inria.diverse.k3.al.annotationprocessor.Aspect
import java.util.List

import static extension org.irisa.diverse.videogen.videoGen.aspects.visitors.VideoGenAspect.*
import static extension org.irisa.diverse.videogen.videoGen.aspects.visitors.SequenceAspect.*
import static extension org.irisa.diverse.videogen.videoGen.aspects.visitors.OptionalAspect.*

@Aspect(className=VideoGen)
class VideoGenDurationConstraintsAspect extends LoggableVisitor {
	
	public var List<IntVar> variables
	private var List<Integer> constants
    private var IntVar objective
    private var int indice
    public var Solver solver
    
	def void visit() {
		_self.solver = new Solver("Min max durations constraints")
		_self.indice = 0
		val videoNumber = _self.videos.size
		
		// Define the objective scalar with given contraints
		_self.objective = VariableFactory.bounded("objective", _self.minUserConstraint, _self.maxUserConstraint, _self.solver)
		_self.variables = newArrayOfSize(videoNumber) // Used to insert optional's coefficient
		_self.constants = newIntArrayOfSize(videoNumber) // Used to insert video durations. Must be a partition of coefs
		
		//_self.log.info("VideoGen User Contraints Visitor started...")
		//_self.log.info("\t => minConstraint=" + min + ", maxConstraint=" + max)
		
		// Call the visitor
		_self.transitions.filter[it instanceof Sequence]
			.map[it as Sequence]
			.filter[active]
			.forEach[visit(_self)]
		
		// Create and post constraints by using constraint factories
        _self.solver.post(IntConstraintFactory.scalar(_self.variables, _self.constants, _self.objective));
        //log.info(_self.solver.toString());
        // Launch the resolution process
        _self.solver.findOptimalSolution(ResolutionPolicy.MAXIMIZE, _self.objective);
        //solver.findParetoFront(ResolutionPolicy.MAXIMIZE, objective);
        //solver.findAllSolutions
        // Print search statistics
        Chatterbox.printStatistics(_self.solver);
        // Print solutions
	    //log.info("Solutions selected " + _self.variables.map[it.getName() + "=" + it.getValue()].join(", "))
        
        // Then apply constraints
		_self.transitions.filter[it instanceof Sequence]
			.map[it as Sequence]
			.filter[active]
			.forEach[applyConstraints(_self)]
        
        // Get all solutions
        val solutions = _self.solver.findAllSolutions
        //log.info("Solutions max = " + solutions)
        _self.variantes = solutions.intValue
        var i = 0
        do {
        	i++
		    //log.info("- Solutions " + i)
		    for (IntVar coef: _self.variables) {
		    	//log.info("\t" + variables.map[it.getName() + "=" + it.getValue()].join(", "))
		    }
        } while (_self.solver.nextSolution())
	}
	
	
	def public void addVar(IntVar intvar, int duration) {
		_self.variables.set(_self.indice, intvar)
		_self.constants.set(_self.indice, duration)
		_self.indice = _self.indice + 1
	}
}

@Aspect(className=Sequence)
class SequenceAspect {

	def void visit(VideoGen vid) {
		if (_self instanceof Optional) {
			_self.visit(vid)
		} else if (_self instanceof Mandatory) {
			_self.visit(vid)
		} else if (_self instanceof Alternatives) {
			_self.visit(vid)
		}
	}
	
	def void applyConstraints(VideoGen vid) {
		if (_self instanceof Optional) {
			_self.applyConstraints(vid)
		} else if (_self instanceof Alternatives) {
			_self.applyConstraints(vid)
		}
	}
}	
@Aspect(className=Alternatives)
class AlternativesAspect {
	
	def void visit(VideoGen vid) {
		val optionsSize = _self.options.size
		val localVars = newArrayOfSize(optionsSize)
		var localCount = 0
		for (Optional opt: _self.options) {
			val ft = opt.visit(vid)
			localVars.set(localCount, ft)
			localCount++
		}
		
		// Create the clause
		val logOp = _self.createAlternativesXorClause(localVars)
		SatFactory.addClauses(logOp, vid.solver)
	}
	
	def void applyConstraints(VideoGen vid) {
		_self.options.forEach[applyConstraints(vid)]
	}
	
	/*
	 * Constructs the Xor constraints fro man Alternative
	 * 
	 * Result is :
	 * 		logOp = LogOp.xor(lastVar,
	 *			LogOp.xor(...
	 *				LogOp.xor(firstVar, secondVar)))
	 */
	def private LogOp createAlternativesXorClause(IntVar[] vars) {
		var LogOp logOp = null
		var BoolVar firstVar = vars.head  as BoolVar
		// Browse except the first element

		for (IntVar boolVar: vars.tail) {
			if (logOp == null) {
				logOp = LogOp.xor(firstVar, boolVar as BoolVar)
			} else {
				logOp = LogOp.xor(boolVar as BoolVar, logOp)
			}
		}
		logOp
	}
}

@Aspect(className=Optional)
class OptionalAspect {
	
	def IntVar visit(VideoGen vid) {
		// For choco, a bool is a integer between 0 and 1
		var IntVar ft
		if (_self.active) {	
			if (_self.selected) {
				ft = VariableFactory.fixed(_self.name, 1, vid.solver)
			} else {
				ft = VariableFactory.bool(_self.name, vid.solver)
			}
		} else {
			ft = VariableFactory.fixed(_self.name, 0, vid.solver)
		}
		vid.addVar(ft, _self.video.duration)
		ft
	}
	
	def void applyConstraints(VideoGen vid) {
		if (vid.variables.filter[value == 0].exists[name == _self.name]) {
			_self.active = false
		}
	}
}

@Aspect(className=Mandatory)
class MandatoryAspect {
	
	def void visit(VideoGen vid) {
		// A mandatory has a fixed coef value of 1, mandatory right ;)
		vid.addVar(VariableFactory.fixed(_self.name, 1, vid.solver), _self.video.duration)
	}
}
