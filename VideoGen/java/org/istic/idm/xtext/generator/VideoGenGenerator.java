/**
 * generated by Xtext
 */
package org.istic.idm.xtext.generator;

import com.google.common.collect.Iterators;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.istic.idm.xtext.VideoGenStandaloneSetup;
import org.istic.idm.xtext.videoGen.Alternatives;
import org.istic.idm.xtext.videoGen.Mandatory;
import org.istic.idm.xtext.videoGen.Optional;
import org.istic.idm.xtext.videoGen.Sequence;
import org.istic.idm.xtext.videoGen.Statement;
import org.istic.idm.xtext.videoGen.VideoGen;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class VideoGenGenerator implements IGenerator {
  public void saveVideoGen(final URI uri, final VideoGen videoGen) {
    try {
      ResourceSetImpl _resourceSetImpl = new ResourceSetImpl();
      Resource rs = _resourceSetImpl.createResource(uri);
      EList<EObject> _contents = rs.getContents();
      _contents.add(videoGen);
      HashMap<Object, Object> _hashMap = new HashMap<Object, Object>();
      rs.save(_hashMap);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public VideoGen loadVideoGen(final URI uri) {
    VideoGen _xblockexpression = null;
    {
      VideoGenStandaloneSetup.doSetup();
      ResourceSetImpl _resourceSetImpl = new ResourceSetImpl();
      Resource res = _resourceSetImpl.getResource(uri, true);
      EList<EObject> _contents = res.getContents();
      EObject _get = _contents.get(0);
      _xblockexpression = ((VideoGen) _get);
    }
    return _xblockexpression;
  }
  
  public void doGenerate(final URI uri) {
    VideoGen videoGen = this.loadVideoGen(uri);
    EList<Statement> _statements = videoGen.getStatements();
    final Consumer<Statement> _function = (Statement statement) -> {
      int statementIndice = 0;
      if ((statement instanceof Mandatory)) {
        Sequence _sequence = ((Mandatory)statement).getSequence();
        _sequence.setName(("Mandatory_" + Integer.valueOf(statementIndice)));
      }
      if ((statement instanceof Optional)) {
        Sequence _sequence_1 = ((Optional)statement).getSequence();
        _sequence_1.setName(("Optional_" + Integer.valueOf(statementIndice)));
        int _probability = ((Optional)statement).getProbability();
        boolean _equals = Integer.valueOf(_probability).equals(null);
        if (_equals) {
          ((Optional)statement).setProbability(50);
        }
      }
      int alternateIndice = 0;
      if ((statement instanceof Alternatives)) {
        EList<Optional> _options = ((Alternatives)statement).getOptions();
        final Function1<Optional, Boolean> _function_1 = (Optional it) -> {
          int _probability_1 = it.getProbability();
          return Boolean.valueOf(Integer.valueOf(_probability_1).equals(null));
        };
        Iterable<Optional> _filter = IterableExtensions.<Optional>filter(_options, _function_1);
        int totalUndefinedOptions = ((Object[])Conversions.unwrapArray(_filter, Object.class)).length;
        if ((totalUndefinedOptions == 0)) {
          totalUndefinedOptions = 1;
        }
        int alreadyDefinedProbability = 0;
        EList<Optional> _options_1 = ((Alternatives)statement).getOptions();
        for (final Optional optional : _options_1) {
          int _alreadyDefinedProbability = alreadyDefinedProbability;
          int _probability_1 = optional.getProbability();
          alreadyDefinedProbability = (_alreadyDefinedProbability + _probability_1);
        }
        int leftProbability = ((100 - alreadyDefinedProbability) / totalUndefinedOptions);
        EList<Optional> _options_2 = ((Alternatives)statement).getOptions();
        for (final Optional optional_1 : _options_2) {
          int _probability_2 = optional_1.getProbability();
          boolean _equals_1 = Integer.valueOf(_probability_2).equals(null);
          if (_equals_1) {
            optional_1.setProbability(leftProbability);
          }
        }
        int indice = 0;
        EList<Optional> _options_3 = ((Alternatives)statement).getOptions();
        final Function1<Optional, Sequence> _function_2 = (Optional it) -> {
          return it.getSequence();
        };
        List<Sequence> _map = ListExtensions.<Optional, Sequence>map(_options_3, _function_2);
        for (final Sequence sequence : _map) {
          sequence.setName(((("Alternative_Sequence_" + Integer.valueOf(alternateIndice)) + "_") + Integer.valueOf(indice)));
        }
        indice++;
        alternateIndice++;
      }
      statementIndice++;
    };
    _statements.forEach(_function);
    URI _createURI = URI.createURI("controls/restructured.vg");
    this.saveVideoGen(_createURI, videoGen);
  }
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess fsa) {
    TreeIterator<EObject> _allContents = resource.getAllContents();
    Iterator<Sequence> _filter = Iterators.<Sequence>filter(_allContents, Sequence.class);
    final Function1<Sequence, String> _function = (Sequence it) -> {
      return it.getUrl();
    };
    Iterator<String> _map = IteratorExtensions.<Sequence, String>map(_filter, _function);
    String _join = IteratorExtensions.join(_map, "\n");
    fsa.generateFile("controls/videos-list.txt", _join);
    final StringBuffer content = new StringBuffer();
    TreeIterator<EObject> _allContents_1 = resource.getAllContents();
    Iterator<VideoGen> _filter_1 = Iterators.<VideoGen>filter(_allContents_1, VideoGen.class);
    final Procedure1<VideoGen> _function_1 = (VideoGen videoGen) -> {
      EList<Statement> _statements = videoGen.getStatements();
      final Consumer<Statement> _function_2 = (Statement statement) -> {
        if ((statement instanceof Mandatory)) {
          Sequence _sequence = ((Mandatory)statement).getSequence();
          String _name = _sequence.getName();
          String _plus = ("Mandatory " + _name);
          String _plus_1 = (_plus + "\n");
          content.append(_plus_1);
        } else {
          if ((statement instanceof Optional)) {
            Sequence _sequence_1 = ((Optional)statement).getSequence();
            String _name_1 = _sequence_1.getName();
            String _plus_2 = ("Optional " + _name_1);
            String _plus_3 = (_plus_2 + "\n");
            content.append(_plus_3);
          } else {
            if ((statement instanceof Alternatives)) {
              String _name_2 = ((Alternatives)statement).getName();
              String _plus_4 = ("Alternatives " + _name_2);
              String _plus_5 = (_plus_4 + "\n");
              content.append(_plus_5);
              EList<Optional> _options = ((Alternatives)statement).getOptions();
              final Consumer<Optional> _function_3 = (Optional option) -> {
                Sequence _sequence_2 = option.getSequence();
                String _name_3 = _sequence_2.getName();
                String _plus_6 = ("\t Option " + _name_3);
                String _plus_7 = (_plus_6 + "\n");
                content.append(_plus_7);
              };
              _options.forEach(_function_3);
            }
          }
        }
      };
      _statements.forEach(_function_2);
    };
    IteratorExtensions.<VideoGen>forEach(_filter_1, _function_1);
    String _string = content.toString();
    fsa.generateFile("controls/structure.txt", _string);
  }
}
