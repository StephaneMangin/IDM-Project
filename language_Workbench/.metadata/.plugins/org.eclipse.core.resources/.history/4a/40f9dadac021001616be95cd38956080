package org.irisa.diverse.videogen.videoGen.aspects

import fr.inria.diverse.k3.al.annotationprocessor.Aspect
import fr.inria.diverse.k3.al.annotationprocessor.InitializeModel
import fr.inria.diverse.k3.al.annotationprocessor.Main
import fr.inria.diverse.k3.al.annotationprocessor.OverrideAspectMethod
import fr.inria.diverse.k3.al.annotationprocessor.Step
import java.io.File
import java.io.FileWriter
import java.util.HashMap
import java.util.List
import org.chocosolver.solver.Solver
import org.chocosolver.solver.constraints.IntConstraintFactory
import org.chocosolver.solver.trace.Chatterbox
import org.chocosolver.solver.variables.IntVar
import org.chocosolver.solver.variables.VariableFactory
import org.chocosolver.solver.constraints.SatFactory
import org.chocosolver.solver.ResolutionPolicy
import org.chocosolver.solver.constraints.nary.cnf.LogOp
import org.chocosolver.solver.variables.BoolVar
import org.irisa.diverse.videogen.transformations.VideoGenTransform
import org.irisa.diverse.videogen.transformations.utils.DistributedRandomNumberGenerator
import org.irisa.diverse.videogen.videoGen.Alternatives
import org.irisa.diverse.videogen.videoGen.Delay
import org.irisa.diverse.videogen.videoGen.Generate
import org.irisa.diverse.videogen.videoGen.Initialize
import org.irisa.diverse.videogen.videoGen.Mandatory
import org.irisa.diverse.videogen.videoGen.Optional
import org.irisa.diverse.videogen.videoGen.Sequence
import org.irisa.diverse.videogen.videoGen.Transition
import org.irisa.diverse.videogen.videoGen.Video
import org.irisa.diverse.videogen.videoGen.VideoGen
import java.util.logging.Logger
import java.util.logging.FileHandler
import java.util.logging.SimpleFormatter
import org.irisa.diverse.videogen.videoGen.aspects.visitors.VideoGenUserContraintsVisitor
import java.nio.file.Paths
import org.eclipse.core.resources.ResourcesPlugin
import org.irisa.diverse.videogen.transformations.helpers.SystemHelper
import java.nio.file.Path
import org.irisa.diverse.videogen.videoGen.aspects.visitors.VideoGenSetupVisitor
import org.irisa.diverse.videogen.videoGen.aspects.visitors.VideoGenVariantsVisitor
import org.irisa.diverse.videogen.videoGen.aspects.visitors.VideoGenContraintsMinMaxVisitor
import static extension org.irisa.diverse.videogen.videoGen.aspects.InitializeAspect.*
import static extension org.irisa.diverse.videogen.videoGen.aspects.VideoGenAspect.*
import static extension org.irisa.diverse.videogen.videoGen.aspects.VideoAspect.*
import java.util.ArrayList
import java.util.Map
import org.irisa.diverse.videogen.videoGen.aspects.utils.LoggableVisitor

@Aspect(className=VideoGen)
class VideoGenAspect {
	
	private VideoGenSetupVisitor setupVisitor = new VideoGenSetupVisitor()
	private VideoGenVariantsVisitor variantsVisitor = new VideoGenVariantsVisitor()
	private VideoGenContraintsMinMaxVisitor durationVisitor = new VideoGenContraintsMinMaxVisitor(false)
	private VideoGenUserContraintsVisitor userConstraintsVisitor = new VideoGenUserContraintsVisitor()
	private Boolean onceSetuped = false
	private long nanotimeStart = 0
	private long nanotimeEnd = 0
	protected static Logger log = Logger.getLogger("VideoGenAspect")
	private static Path workspacePath = Paths.get(ResourcesPlugin.workspace.root.projects.get(0).locationURI)
	private static Path logPath = Paths.get(workspacePath + "/logs")
	//private static List<String> args = null
    
	@Main
	def void main() {
		_self.execute
	}

//	@Step
//	def private void parseArgs() {
//		if (_self.args != null) {
//	        val parser = new CmdLineParser()
//	        val min = parser.addIntegerOption("minimumDuration")
//	        val max = parser.addIntegerOption("maximumDuration")
//	
//	        try {
//	            parser.parse(args)
//	            _self.minUserConstraint = parser.getOptionValue(min, _self.minDurationConstraint) as Integer
//				_self.maxUserConstraint = parser.getOptionValue(max, _self.maxDurationConstraint) as Integer
//	        }
//	        catch ( CmdLineParser.OptionException e ) {
//	            System.err.println(e.getMessage());
//	        }
//	    }
//	}
	
	@Step
	def private void setup() {
		val start = System.nanoTime
		
		_self.setupVisitor.visit(_self)
		
		// Initialize self variables
		_self.variantes = _self.variantsVisitor.visit(_self).variants
		// Duration initialization
		_self.durationVisitor.visit(_self)
		// Constraints initialization
		_self.minDurationConstraint = _self.durationVisitor.minDuration
		_self.maxDurationConstraint = _self.durationVisitor.maxDuration
		
		
		if (!_self.onceSetuped) {
			// Log is reset before use
			SystemHelper.mkDirs(logPath)
			val FileHandler fh = new FileHandler(logPath + "/" + log.name + ".log", true)
	        val formatter = new SimpleFormatter()
	        fh.setFormatter(formatter)
			log.addHandler(fh)
			_self.onceSetuped = true
		}
		
		log.info("#### VideoGen, time to setup " + (System.nanoTime - start))
		
	}
	
	@Step
	@InitializeModel
	def public void initializeModel(List<String> args){
		_self.setup
		//_self.args = args
		//_self.parseArgs()
		
		log.info("Initialize model with " + args)
	}
	
	@Step
	def public void execute() {
		// Then process each sequences
		_self.nanotimeStart = System.nanoTime
		VideoGenHelper.getInitialize(_self).execute(_self)
		_self.nanotimeEnd = System.nanoTime
		log.info("#### VideoGen, time to execute " + (_self.nanotimeEnd - _self.nanotimeStart))
	}	
	
	/**
	 * Start the computation (model transformation) of all selected video to create the final sequence (PlayList format)
	 * 
	 */
	@Step
	def public void compute() {
		val videos = new HashMap
		log.info("##### VideoGen '" + _self.name + "' start computation.")
		VideoGenHelper.allSelectedVideos(_self).forEach[videos.put(name, true)]
		// TODO: Manage model transformation here
		// TODO: re-implement the initial IDM project model transformation. See master branch package 'fr.nemomen.utils'.
		val content = VideoGenTransform.toM3U(_self, false, videos)
		log.info("##### Videos computation result in M3U format : ")
		log.info(content)
		val playlist = _self.saveGeneratedModel(content)
		//_self.launchReader(playlist)
	}
	
	/**
	 * Save the given playlist content in a temporary file (hashed by content named)
	 * 
	 */
	def private File saveGeneratedModel(String content) {
		// Create the temporary file to receive playlist as M3U
		val playlist = File.createTempFile(String.valueOf(content.hashCode), "-videogen.m3u")
		val writer = new FileWriter(playlist)
		writer.write(content)
		writer.flush
		writer.close
		playlist
	}
	
	/**
	 * Launch vlc instance with the provided playlist
	 * 
	 */
	def private void launchReader(File playlist) {
		// Start VLC
		// TODO: add a new tab inside eclipse to start a video player...
		// If possible (see Jave implementation from org.irisa.diverse.transformations.strategies)
		val p = new ProcessBuilder(
			"vlc",
			"--playlist-autostart",
			"--playlist-tree",
			"--no-overlay",
			playlist.toPath.toString)
		p.start()
	}
	
}

@Aspect(className=Transition)
abstract class TransitionAspect {

	public VideoGen videoGen = null
	public Boolean executed = false
	public Boolean callnextTransition = true
	
	@Step
	def public void execute(VideoGen videoGen) {
		
	}
}


@Aspect(className=Video)
class VideoAspect {
			
	/**
	 * Select this video and apply any of needed operations (conversion or rename for example)
	 * 
	 */
	@Step
	def public void select() {
		VideoGenAspect.log.info(_self.toString)
		if (!_self.url.startsWith("/")) {
			val prefix = ResourcesPlugin.workspace.root.projects.get(0).locationURI.toString.replace("file:", "")
			val newPath = prefix + "/" + _self.url
			VideoGenAspect.log.info(_self.url + "=>" + newPath)
			_self.url = newPath
		}
		// Add duration and VideoCodec MimeType
		VideoGenTransform.addMetadata(_self)
		VideoGenAspect.log.info("##### Video '" + _self.name + "' has been selected.")
	}
}

@Aspect(className=Delay)
class DelayAspect extends TransitionAspect {

}

@Aspect(className=Sequence)
abstract class SequenceAspect extends TransitionAspect {

	@Step
	@OverrideAspectMethod
	def public void execute(VideoGen videoGen) {
		
	}
	
}

@Aspect(className=Alternatives)
class AlternativesAspect extends SequenceAspect {

	@Step
	@OverrideAspectMethod
	def public void execute(VideoGen videoGen) {
		
		// Selected is always true on Alternatives sequences
		// Optional could be linked together for alterantives management
		// A bind relation could be used to replace this data structure (maybe without common sense)
		_self.selected = true
		val selectedOption = VideoGenHelper.selectOption(_self)
		if (selectedOption != null) {
			selectedOption.selected = true
			_self.video = selectedOption.video
			_self.video.select
			// Manage optional next sequence
			_self.options
			.filter[active]
			.filter[video == _self.video]
			.filter[nextTransition != null]
			.forEach[ 
				nextTransition.execute(videoGen)
				// Call of nextTransition.process will not be called in super
				_self.callnextTransition = false
			]
		}
		//_self.super_execute(videoGen)
		VideoGenAspect.log.info("##### '" + _self + "' is being processed.")
		
		// First apply the constraint model before execution
		new VideoGenUserContraintsVisitor().visit(videoGen, videoGen.minUserConstraint, videoGen.maxUserConstraint)
		
		// Stop invariant while looping the model
		if (!_self.executed) {
			// Call the next sequence in all case
			if (_self.nextTransition !== null) {
				//Don't forget to reset current state
				_self.executed = true
				// Before calling next sequence
				if (_self.callnextTransition) {
					_self.nextTransition.execute(videoGen)
				}
			}
		}
		
	}
}

@Aspect(className=Mandatory)
class MandatoryAspect extends SequenceAspect {
	
	@Step
	@OverrideAspectMethod
	def public void execute(VideoGen videoGen) {
		if (_self.active && !_self.executed) {
			_self.video.select
			_self.selected = true
		}
		//_self.super_execute(videoGen)
		
		VideoGenAspect.log.info("##### '" + _self + "' is being processed.")
		
		// First apply the constraint model before execution
		new VideoGenUserContraintsVisitor().visit(videoGen, videoGen.minUserConstraint, videoGen.maxUserConstraint)
		
		// Stop invariant while looping the model
		if (!_self.executed) {
			// Call the next sequence in all case
			if (_self.nextTransition !== null) {
				//Don't forget to reset current state
				_self.executed = true
				// Before calling next sequence
				if (_self.callnextTransition) {
					_self.nextTransition.execute(videoGen)
				}
			}
		}
	}
}

@Aspect(className=Optional)
class OptionalAspect extends SequenceAspect {
	
	/**
	 * Is this video is selectable or not ?
	 * applies 50% in case of undefined proba
	 * 
	 * @author Stéphane Mangin <stephane.mangin@freesbee.fr>
	 */
	def private Boolean isSelected() {

		var drng = new DistributedRandomNumberGenerator()

		var float proba

		proba = 50
		if (_self.probability != 0) {
			proba = _self.probability
		}
		drng.addNumber(1, proba)
		drng.addNumber(0, 100 - proba)

		drng.getDistributedRandomNumber() > 0
	}

	@Step
	@OverrideAspectMethod
	def public void execute(VideoGen videoGen) {
		if (_self.active && !_self.executed) {
			if (_self.isSelected()) {
				_self.video.select
				_self.selected = true
			}
		}
		//_self.super_execute(videoGen)
		
		VideoGenAspect.log.info("##### '" + _self + "' is being processed.")
		
		// First apply the constraint model before execution
		new VideoGenUserContraintsVisitor().visit(videoGen, videoGen.minUserConstraint, videoGen.maxUserConstraint)
		
		// Stop invariant while looping the model
		if (!_self.executed) {
			// Call the next sequence in all case
			if (_self.nextTransition !== null) {
				//Don't forget to reset current state
				_self.executed = true
				// Before calling next sequence
				if (_self.callnextTransition) {
					_self.nextTransition.execute(videoGen)
				}
			}
		}
	}
}


@Aspect(className=Initialize)
class InitializeAspect extends TransitionAspect {
	
	@Step
	@OverrideAspectMethod
	def public void execute(VideoGen videoGen) {		
		VideoGenAspect.log.info("##### '" + _self + "' is being processed.")
		
		// First apply the constraint model before execution
		new VideoGenUserContraintsVisitor().visit(videoGen, videoGen.minUserConstraint, videoGen.maxUserConstraint)
		
		// Stop invariant while looping the model
		if (!_self.executed) {
			// Call the next sequence in all case
			if (_self.nextTransition !== null) {
				//Don't forget to reset current state
				_self.executed = true
				// Before calling next sequence
				if (_self.callnextTransition) {
					_self.nextTransition.execute(videoGen)
				}
			}
		}
	}	
}

@Aspect(className=Generate)
class GenerateAspect extends TransitionAspect {
	
	@Step
	@OverrideAspectMethod
	def public void execute(VideoGen videoGen) {
		if (!_self.executed) {
			_self.compute(videoGen)
			// Reinit the model after computation
			videoGen.initializeModel(newArrayList("noreset"))
		}
		//_self.super_execute(videoGen)
		
		VideoGenAspect.log.info("##### '" + _self + "' is being processed.")
		
		// First apply the constraint model before execution
		new VideoGenUserContraintsVisitor().visit(videoGen, videoGen.minUserConstraint, videoGen.maxUserConstraint)
		
		// Stop invariant while looping the model
		if (!_self.executed) {
			// Call the next sequence in all case
			if (_self.nextTransition !== null) {
				//Don't forget to reset current state
				_self.executed = true
				// Before calling next sequence
				if (_self.callnextTransition) {
					_self.nextTransition.execute(videoGen)
				}
			}
		}
	}
	/**s
	 * Call VideogGen.compute()
	 */
	@Step
	def public void compute(VideoGen videoGen) {
		videoGen.compute
	}
}
	/** 
 * Parse the VideoGen model to give helper methods to retrieve various instances
 * 
 * @author Stéphane Mangin <stephane.mangin@freesbee.fr>
 * 
 */
public class VideoGenHelper {
	
		
	/**
	 * Return the Initialize as the main entry point
	 * 
	 */
	def static Initialize getInitialize(VideoGen videoGen) {
		for (Transition transition : videoGen.transitions) { 
			if (transition instanceof Initialize) {
				return transition
			}
		}
		null
	}
	
	/**
	 * Return the Generate as the main end point
	 * 
	 */
	def static Generate getGenerate(VideoGen videoGen) {
		for (Transition transition : videoGen.transitions) { 
			if (transition instanceof Generate) {
				return transition
			}
		}
		null
	}
	
 	/**
 	 * Return all transitions contained in a VideoGen instance
 	 * 
 	 */ 
    def static List<Transition> allTransitions(VideoGen videoGen) {
		val List<Transition> transitions = new ArrayList<Transition>
        val initialize = getInitialize(videoGen)
		transitions.add(initialize)
		var transition = initialize.nextTransition
        while (transition !== null) {
			if (initialize.equals(transition)) {
				transition = null
			} else {
				transitions.add(transition)
				transition = transition.nextTransition
			}
        }
		transitions
    }
    
 	/**
 	 * Return all sequences contained in a VideoGen instance
 	 * 
 	 */ 
    def static List<Sequence> allSequences(VideoGen videoGen) {
        allTransitions(videoGen).filter[it instanceof Sequence].map[it as Sequence].toList
    }
    
 	/**
 	 * Return all videos from all sequences contained in a VideoGen instance
 	 * 
 	 */ 
    def static List<Video> allVideos(VideoGen videoGen) {
		val List<Video> videos = new ArrayList<Video>
		allSequences(videoGen).forEach[
			if (it instanceof Alternatives) {
				it.options.forEach[option |
					videos += option.video
				]
			} else {
				videos += it.video
			}
		]	
        videos.filter[video | video !== null].toList
    }
    
 	/**
 	 * Return all videos from active sequences contained in a VideoGen instance
 	 * 
 	 */ 
    def static List<Video> allActiveVideos(VideoGen videoGen) {
		val List<Video> videos = new ArrayList<Video>
		allSequences(videoGen).filter[active].forEach[
			if (it instanceof Alternatives) {
				it.options.forEach[option |
					videos += option.video
				]
			} else {
				videos += it.video
			}
		]	
        videos.filter[video | video !== null].toList
    }
    
 	/**
 	 * Return all videos from active sequences contained in a VideoGen instance
 	 * 
 	 */ 
    def static List<Video> allSelectedVideos(VideoGen videoGen) {
		val List<Video> videos = new ArrayList<Video>
		allSequences(videoGen).filter[active].filter[selected].forEach[
			if (it instanceof Alternatives) {
				it.options.forEach[option |
					videos += option.video
				]
			} else {
				videos += it.video
			}
		]	
        videos.filter[video | video !== null].toList
    }
	
	
	/**
	 * Return a hashmap with corrected probabilities for an Alternatives instance.
	 * 
	 * @author Stéphane Mangin <stephane.mangin@freesbee.fr>
	 */
	def public static Map<Optional, Integer> checkProbabilities(Alternatives alternatives) {
		val result = new HashMap<Optional, Integer>
		var totalProb = 0
		var totalProbLeft = 0
		var totalOptions = 0
		var inactivated = 0
		for (option : alternatives.options) {
			if (option.active) {
				if (option.probability == 0) {
					totalOptions++
				}
				totalProb += option.probability
				result.put(option, option.probability)
			} else {
				inactivated++
				totalProbLeft += option.probability
			}
		}
		if (result.size != 0) {
			if (result.size == 1) {
				result.replace(result.keySet.get(0), 100)
			} else if (inactivated != 0) {
				for (name : result.keySet) {
					val percentageLeft = totalProbLeft / inactivated
					result.put(name, result.get(name) + percentageLeft)
				}
			} else {
				for (name : result.keySet) {
					if (result.get(name) == 0) {
						val percentageLeft = (100 - totalProb) / totalOptions
						result.put(name, percentageLeft)
					}
				}
			}
		}
		result
	}

	/**
 	 * Process options to find the selectable video
 	 * 
 	 */
	def public static Optional selectOption(Alternatives alternatives) {

		val drng = new DistributedRandomNumberGenerator()
		val checkedProbabilities = VideoGenHelper.checkProbabilities(alternatives)
		if (checkedProbabilities.empty) {
			return null
		}
		checkedProbabilities.forEach[option, proba|
			drng.addNumber(checkedProbabilities.keySet.toList.indexOf(option), proba)
		] 
		checkedProbabilities.keySet.get(drng.getDistributedRandomNumber())
	}

}
class VideoGenUserContraintsVisitor extends LoggableVisitor {
	
	private IntVar[] variables
	private int[] constants
    private Solver solver
    private IntVar objective
    private int indice
    
    new() {
		// Define a new solver
    	solver = new Solver("Min max durations constraints")
    	indice = 0
    }
    
	def visit(VideoGen vid, int min, int max) {
		val videoNumber = VideoGenHelper.allVideos(vid).size
		
		// Define the objective scalar with given contraints
		objective = VariableFactory.bounded("objective", min, max, solver)
		variables = newArrayOfSize(videoNumber) // Used to insert optional's coefficient
		constants = newIntArrayOfSize(videoNumber) // Used to insert video durations. Must be a partition of coefs
		
		log.info("VideoGen User Contraints Visitor started...")
		log.info("\t => minConstraint=" + min + ", maxConstraint=" + max)
		
		// Call the visitor
		VideoGenHelper.allSequences(vid).filter[active].forEach[visit]
		
		// Create and post constraints by using constraint factories
        solver.post(IntConstraintFactory.scalar(variables, constants, objective));
        log.info(solver.toString());
        // Launch the resolution process
        solver.findOptimalSolution(ResolutionPolicy.MAXIMIZE, objective);
        //solver.findParetoFront(ResolutionPolicy.MAXIMIZE, objective);
        //solver.findAllSolutions
        // Print search statistics
        Chatterbox.printStatistics(solver);
        // Print solutions
	    log.info("Solutions selected " + variables.map[it.getName() + "=" + it.getValue()].join(", "))
        
        // Then apply constraints
		VideoGenHelper.allSequences(vid).filter[active].forEach[applyConstraints]
        
        // Get all solutions
        val solutions = solver.findAllSolutions
        log.info("Solutions max = " + solutions)
        vid.variantes = solutions.intValue
        var i = 0
        do {
        	i++
		    log.info("- Solutions " + i)
		    for (IntVar coef: variables) {
		    	log.info("\t" + variables.map[it.getName() + "=" + it.getValue()].join(", "))
		    }
        } while (solver.nextSolution())
	}
	
	def private void visit(Sequence tra) {
		if (tra instanceof Optional) {
			tra.visit
		} else if (tra instanceof Mandatory) {
			tra.visit
		} else if (tra instanceof Alternatives) {
			tra.visit
		}
	}
		
	def private visit(Alternatives alt) {
		val optionsSize = alt.options.size
		val localVars = newArrayOfSize(optionsSize)
		var localCount = 0
		for (Optional opt: alt.options) {
			val ft = opt.visit
			localVars.set(localCount, ft)
			localCount++
		}
		
		// Create the clause
		val logOp = createAlternativesXorClause(localVars)
		SatFactory.addClauses(logOp, solver)
	}
	
	def private IntVar visit(Optional opt) {
		// For choco, a bool is a integer between 0 and 1
		var IntVar ft
		if (opt.active) {	
			if (opt.selected) {
				ft = VariableFactory.fixed(opt.name, 1, solver)
			} else {
				ft = VariableFactory.bool(opt.name, solver)
			}
		} else {
			ft = VariableFactory.fixed(opt.name, 0, solver)
		}
		addVar(ft, opt.video.duration)
		ft
	}
	
	def private visit(Mandatory man) {
		// A mandatory has a fixed coef value of 1, mandatory right ;)
		addVar(VariableFactory.fixed(man.name, 1, solver), man.video.duration)
	}
	
	def private void addVar(IntVar intvar, int duration) {
		variables.set(indice, intvar)
		constants.set(indice, duration)
		indice++
	}
	
	/*
	 * Constructs the Xor constraints fro man Alternative
	 * 
	 * Result is :
	 * 		logOp = LogOp.xor(lastVar,
	 *			LogOp.xor(...
	 *				LogOp.xor(firstVar, secondVar)))
	 */
	def private LogOp createAlternativesXorClause(IntVar[] vars) {
		var LogOp logOp = null
		var BoolVar firstVar = vars.head  as BoolVar
		// Browse except the first element

		for (IntVar boolVar: vars.tail) {
			if (logOp == null) {
				logOp = LogOp.xor(firstVar, boolVar as BoolVar)
			} else {
				logOp = LogOp.xor(boolVar as BoolVar, logOp)
			}
		}
		logOp
	}
	
	def private void applyConstraints(Sequence tra) {
		if (tra instanceof Optional) {
			tra.applyConstraints
		} else if (tra instanceof Alternatives) {
			tra.applyConstraints
		}
	}
	
	def private void applyConstraints(Alternatives alt) {
		alt.options.forEach[applyConstraints]
	}
	
	def private void applyConstraints(Optional opt) {
		if (variables.filter[value == 0].exists[name == opt.name]) {
			opt.active = false
		}
	}
	
}