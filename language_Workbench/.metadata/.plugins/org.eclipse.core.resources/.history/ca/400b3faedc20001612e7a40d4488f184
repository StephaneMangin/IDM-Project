package org.irisa.diverse.videogen.videogenl.aspects;

import com.google.common.base.Objects;

import fr.inria.diverse.k3.al.annotationprocessor.Aspect;
import fr.inria.diverse.k3.al.annotationprocessor.OverrideAspectMethod;
import fr.inria.diverse.k3.al.annotationprocessor.Step;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.irisa.diverse.videogen.transformations.utils.DistributedRandomNumberGenerator;
import org.irisa.diverse.videogen.videoGen.aspects.visitors.VideoGenUserContraintsVisitor;
import org.irisa.diverse.videogen.videogenl.videoGen.Alternatives;
import org.irisa.diverse.videogen.videogenl.videoGen.Optional;
import org.irisa.diverse.videogen.videogenl.videoGen.Transition;
import org.irisa.diverse.videogen.videogenl.videoGen.Video;
import org.irisa.diverse.videogen.videogenl.videoGen.VideoGen;
import org.irisa.diverse.videogen.videogenl.aspects.AlternativesAspectAlternativesAspectProperties;
import org.irisa.diverse.videogen.videogenl.aspects.SequenceAspect;
import org.irisa.diverse.videogen.videogenl.aspects.TransitionAspect;
import org.irisa.diverse.videogen.videogenl.aspects.VideoAspect;
import org.irisa.diverse.videogen.videogenl.aspects.VideoGenAspect;

@Aspect(className = Alternatives.class)
@SuppressWarnings("all")
public class AlternativesAspect extends SequenceAspect {
  /**
   * Return a hashmap with corrected probabilities for an Alternatives instance.
   * 
   * @author St√©phane Mangin <stephane.mangin@freesbee.fr>
   */
  private static Map<Optional, Integer> checkProbabilities(final Alternatives _self) {
    final org.irisa.diverse.videogen.videogenl.aspects.AlternativesAspectAlternativesAspectProperties _self_ = org.irisa.diverse.videogen.videogenl.aspects.AlternativesAspectAlternativesAspectContext.getSelf(_self);
    Object result = null;
    result = _privk3_checkProbabilities(_self_, _self);;
    return (java.util.Map<org.irisa.diverse.videogen.videogenl.videoGen.Optional, java.lang.Integer>)result;
  }
  
  /**
   * Process options to find the selectable video
   */
  private static Optional selectOption(final Alternatives _self) {
    final org.irisa.diverse.videogen.videogenl.aspects.AlternativesAspectAlternativesAspectProperties _self_ = org.irisa.diverse.videogen.videogenl.aspects.AlternativesAspectAlternativesAspectContext.getSelf(_self);
    Object result = null;
    result = _privk3_selectOption(_self_, _self);;
    return (org.irisa.diverse.videogen.videogenl.videoGen.Optional)result;
  }
  
  @Step
  @OverrideAspectMethod
  public static void execute(final Alternatives _self, final VideoGen videoGen) {
    final org.irisa.diverse.videogen.videogenl.aspects.AlternativesAspectAlternativesAspectProperties _self_ = org.irisa.diverse.videogen.videogenl.aspects.AlternativesAspectAlternativesAspectContext.getSelf(_self);
     if (_self instanceof org.irisa.diverse.videogen.videogenl.videoGen.Alternatives){
    					fr.inria.diverse.k3.al.annotationprocessor.stepmanager.StepCommand command = new fr.inria.diverse.k3.al.annotationprocessor.stepmanager.StepCommand() {
    						@Override
    						public void execute() {
    							org.irisa.diverse.videogen.videogenl.aspects.AlternativesAspect._privk3_execute(_self_, (org.irisa.diverse.videogen.videogenl.videoGen.Alternatives)_self,videoGen);
    						}
    					};
    					fr.inria.diverse.k3.al.annotationprocessor.stepmanager.IStepManager manager = fr.inria.diverse.k3.al.annotationprocessor.stepmanager.StepManagerRegistry.getInstance().findStepManager(_self);
    					if (manager != null) {
    						manager.executeStep(_self,command,"Alternatives","execute");
    					} else {
    						command.execute();
    					}
    					;
    } else  if (_self instanceof org.irisa.diverse.videogen.videogenl.videoGen.Sequence){
    					org.irisa.diverse.videogen.videogenl.aspects.SequenceAspect.execute((org.irisa.diverse.videogen.videogenl.videoGen.Sequence)_self,videoGen);
    } else  if (_self instanceof org.irisa.diverse.videogen.videogenl.videoGen.Transition){
    					org.irisa.diverse.videogen.videogenl.aspects.TransitionAspect.execute((org.irisa.diverse.videogen.videogenl.videoGen.Transition)_self,videoGen);
    } else  { throw new IllegalArgumentException("Unhandled parameter types: " + java.util.Arrays.<Object>asList(_self).toString()); };
  }
  
  protected static Map<Optional, Integer> _privk3_checkProbabilities(final AlternativesAspectAlternativesAspectProperties _self_, final Alternatives _self) {
    HashMap<Optional, Integer> _xblockexpression = null;
    {
      final HashMap<Optional, Integer> result = new HashMap<Optional, Integer>();
      int totalProb = 0;
      int totalProbLeft = 0;
      int totalOptions = 0;
      int inactivated = 0;
      EList<Optional> _options = _self.getOptions();
      for (final Optional option : _options) {
        Boolean _active = option.getActive();
        if ((_active).booleanValue()) {
          Integer _probability = option.getProbability();
          boolean _equals = ((_probability).intValue() == 0);
          if (_equals) {
            totalOptions++;
          }
          int _talProb = totalProb;
          Integer _probability_1 = option.getProbability();
          totalProb = (_talProb + (_probability_1).intValue());
          Integer _probability_2 = option.getProbability();
          result.put(option, _probability_2);
        } else {
          inactivated++;
          int _talProbLeft = totalProbLeft;
          Integer _probability_3 = option.getProbability();
          totalProbLeft = (_talProbLeft + (_probability_3).intValue());
        }
      }
      int _size = result.size();
      boolean _notEquals = (_size != 0);
      if (_notEquals) {
        int _size_1 = result.size();
        boolean _equals_1 = (_size_1 == 1);
        if (_equals_1) {
          Set<Optional> _keySet = result.keySet();
          Optional _get = ((Optional[])Conversions.unwrapArray(_keySet, Optional.class))[0];
          result.replace(_get, Integer.valueOf(100));
        } else {
          if ((inactivated != 0)) {
            Set<Optional> _keySet_1 = result.keySet();
            for (final Optional name : _keySet_1) {
              {
                final int percentageLeft = (totalProbLeft / inactivated);
                Integer _get_1 = result.get(name);
                int _plus = ((_get_1).intValue() + percentageLeft);
                result.put(name, Integer.valueOf(_plus));
              }
            }
          } else {
            Set<Optional> _keySet_2 = result.keySet();
            for (final Optional name_1 : _keySet_2) {
              Integer _get_1 = result.get(name_1);
              boolean _equals_2 = ((_get_1).intValue() == 0);
              if (_equals_2) {
                final int percentageLeft = ((100 - totalProb) / totalOptions);
                result.put(name_1, Integer.valueOf(percentageLeft));
              }
            }
          }
        }
      }
      _xblockexpression = result;
    }
    return _xblockexpression;
  }
  
  protected static Optional _privk3_selectOption(final AlternativesAspectAlternativesAspectProperties _self_, final Alternatives _self) {
    Optional _xblockexpression = null;
    {
      final DistributedRandomNumberGenerator drng = new DistributedRandomNumberGenerator();
      final Map<Optional, Integer> checkedProbabilities = AlternativesAspect.checkProbabilities(_self);
      boolean _isEmpty = checkedProbabilities.isEmpty();
      if (_isEmpty) {
        return null;
      }
      final BiConsumer<Optional, Integer> _function = (Optional option, Integer proba) -> {
        Set<Optional> _keySet = checkedProbabilities.keySet();
        List<Optional> _list = IterableExtensions.<Optional>toList(_keySet);
        int _indexOf = _list.indexOf(option);
        drng.addNumber(_indexOf, (proba).intValue());
      };
      checkedProbabilities.forEach(_function);
      Set<Optional> _keySet = checkedProbabilities.keySet();
      int _distributedRandomNumber = drng.getDistributedRandomNumber();
      _xblockexpression = ((Optional[])Conversions.unwrapArray(_keySet, Optional.class))[_distributedRandomNumber];
    }
    return _xblockexpression;
  }
  
  private static void super_execute(final Alternatives _self, final VideoGen videoGen) {
    final org.irisa.diverse.videogen.videogenl.aspects.SequenceAspectSequenceAspectProperties _self_ = org.irisa.diverse.videogen.videogenl.aspects.SequenceAspectSequenceAspectContext.getSelf(_self);
     org.irisa.diverse.videogen.videogenl.aspects.SequenceAspect._privk3_execute(_self_, _self,videoGen);
  }
  
  protected static void _privk3_execute(final AlternativesAspectAlternativesAspectProperties _self_, final Alternatives _self, final VideoGen videoGen) {
    _self.setSelected(Boolean.valueOf(true));
    final Optional selectedOption = AlternativesAspect.selectOption(_self);
    boolean _notEquals = (!Objects.equal(selectedOption, null));
    if (_notEquals) {
      selectedOption.setSelected(Boolean.valueOf(true));
      Video _video = selectedOption.getVideo();
      _self.setVideo(_video);
      Video _video_1 = _self.getVideo();
      VideoAspect.select(_video_1);
      EList<Optional> _options = _self.getOptions();
      final Function1<Optional, Boolean> _function = (Optional it) -> {
        return it.getActive();
      };
      Iterable<Optional> _filter = IterableExtensions.<Optional>filter(_options, _function);
      final Function1<Optional, Boolean> _function_1 = (Optional it) -> {
        Video _video_2 = it.getVideo();
        Video _video_3 = _self.getVideo();
        return Boolean.valueOf(Objects.equal(_video_2, _video_3));
      };
      Iterable<Optional> _filter_1 = IterableExtensions.<Optional>filter(_filter, _function_1);
      final Function1<Optional, Boolean> _function_2 = (Optional it) -> {
        Transition _nextTransition = it.getNextTransition();
        return Boolean.valueOf((!Objects.equal(_nextTransition, null)));
      };
      Iterable<Optional> _filter_2 = IterableExtensions.<Optional>filter(_filter_1, _function_2);
      final Consumer<Optional> _function_3 = (Optional it) -> {
        Transition _nextTransition = it.getNextTransition();
        TransitionAspect.execute(_nextTransition, videoGen);
        TransitionAspect.callnextTransition(_self, Boolean.valueOf(false));
      };
      _filter_2.forEach(_function_3);
    }
    VideoGenAspect.log.info((("##### \'" + _self) + "\' is being processed."));
    VideoGenUserContraintsVisitor _videoGenUserContraintsVisitor = new VideoGenUserContraintsVisitor();
    Integer _minUserConstraint = videoGen.getMinUserConstraint();
    Integer _maxUserConstraint = videoGen.getMaxUserConstraint();
    _videoGenUserContraintsVisitor.visit(videoGen, _minUserConstraint, _maxUserConstraint);
    Boolean _executed = TransitionAspect.executed(_self);
    boolean _not = (!(_executed).booleanValue());
    if (_not) {
      Transition _nextTransition = _self.getNextTransition();
      boolean _tripleNotEquals = (_nextTransition != null);
      if (_tripleNotEquals) {
        TransitionAspect.executed(_self, Boolean.valueOf(true));
        Boolean _callnextTransition = TransitionAspect.callnextTransition(_self);
        if ((_callnextTransition).booleanValue()) {
          Transition _nextTransition_1 = _self.getNextTransition();
          TransitionAspect.execute(_nextTransition_1, videoGen);
        }
      }
    }
  }
}
