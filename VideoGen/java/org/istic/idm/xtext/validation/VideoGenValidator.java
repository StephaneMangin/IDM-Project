/**
 * generated by Xtext
 */
package org.istic.idm.xtext.validation;

import com.google.common.collect.Iterators;
import java.io.File;
import java.util.Iterator;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.istic.idm.xtext.validation.AbstractVideoGenValidator;
import org.istic.idm.xtext.videoGen.Alternatives;
import org.istic.idm.xtext.videoGen.Optional;
import org.istic.idm.xtext.videoGen.Sequence;
import org.istic.idm.xtext.videoGen.VideoGenPackage;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class VideoGenValidator extends AbstractVideoGenValidator {
  public final static String DUPLICATED_DESCRIPTION = "duplicatedDescription";
  
  public final static String DUPLICATED_URL = "duplicatedURL";
  
  public final static String INVALID_NAME = "invalidName";
  
  public final static String INVALID_URL = "invalidUrl";
  
  public final static String INVALID_PROBABILITY = "invalidProbability";
  
  @Check
  public void checkIsUrlExists(final Sequence sequence) {
    String _url = sequence.getUrl();
    File _file = new File(_url);
    boolean _exists = _file.exists();
    boolean _not = (!_exists);
    if (_not) {
      this.error("File not found", 
        VideoGenPackage.Literals.SEQUENCE__URL, 
        VideoGenValidator.INVALID_URL);
    }
  }
  
  @Check
  public void checkUniqueDescription(final Sequence sequence) {
    Resource _eResource = sequence.eResource();
    TreeIterator<EObject> _allContents = _eResource.getAllContents();
    Iterator<Sequence> _filter = Iterators.<Sequence>filter(_allContents, Sequence.class);
    final Function1<Sequence, Boolean> _function = (Sequence seq2) -> {
      boolean _equals = seq2.equals(sequence);
      return Boolean.valueOf((!_equals));
    };
    Iterator<Sequence> _takeWhile = IteratorExtensions.<Sequence>takeWhile(_filter, _function);
    final Procedure1<Sequence> _function_1 = (Sequence seq2) -> {
      String _description = seq2.getDescription();
      String _description_1 = sequence.getDescription();
      boolean _equals = _description.equals(_description_1);
      if (_equals) {
        this.info("Duplicated description", 
          VideoGenPackage.Literals.SEQUENCE__DESCRIPTION, 
          VideoGenValidator.DUPLICATED_DESCRIPTION);
      }
    };
    IteratorExtensions.<Sequence>forEach(_takeWhile, _function_1);
  }
  
  @Check
  public void checkUniqueURL(final Sequence sequence) {
    Resource _eResource = sequence.eResource();
    TreeIterator<EObject> _allContents = _eResource.getAllContents();
    Iterator<Sequence> _filter = Iterators.<Sequence>filter(_allContents, Sequence.class);
    final Function1<Sequence, Boolean> _function = (Sequence seq2) -> {
      boolean _equals = seq2.equals(sequence);
      return Boolean.valueOf((!_equals));
    };
    Iterator<Sequence> _takeWhile = IteratorExtensions.<Sequence>takeWhile(_filter, _function);
    final Procedure1<Sequence> _function_1 = (Sequence seq2) -> {
      String _url = seq2.getUrl();
      String _url_1 = sequence.getUrl();
      boolean _equals = _url.equals(_url_1);
      if (_equals) {
        this.info("Duplicated url", 
          VideoGenPackage.Literals.SEQUENCE__URL, 
          VideoGenValidator.DUPLICATED_URL);
      }
    };
    IteratorExtensions.<Sequence>forEach(_takeWhile, _function_1);
  }
  
  @Check
  public void checkUniqueIdentifiers(final Sequence sequence) {
    Resource _eResource = sequence.eResource();
    TreeIterator<EObject> _allContents = _eResource.getAllContents();
    Iterator<Sequence> _filter = Iterators.<Sequence>filter(_allContents, Sequence.class);
    final Function1<Sequence, Boolean> _function = (Sequence seq2) -> {
      boolean _equals = seq2.equals(sequence);
      return Boolean.valueOf((!_equals));
    };
    Iterator<Sequence> _takeWhile = IteratorExtensions.<Sequence>takeWhile(_filter, _function);
    final Procedure1<Sequence> _function_1 = (Sequence seq2) -> {
      String _name = seq2.getName();
      String _name_1 = sequence.getName();
      boolean _equals = _name.equals(_name_1);
      if (_equals) {
        this.error("Sequence name should be unique.", 
          VideoGenPackage.Literals.SEQUENCE__NAME, 
          VideoGenValidator.INVALID_NAME);
      }
    };
    IteratorExtensions.<Sequence>forEach(_takeWhile, _function_1);
  }
  
  @Check
  public void checkOptionalProbability(final Optional optional) {
    int _probability = optional.getProbability();
    boolean _greaterThan = (_probability > 100);
    if (_greaterThan) {
      this.error("Optional probability should not be higher than 100%", 
        VideoGenPackage.Literals.OPTIONAL__PROBABILITY, 
        VideoGenValidator.INVALID_PROBABILITY);
    } else {
      int _probability_1 = optional.getProbability();
      boolean _equals = (_probability_1 == 100);
      if (_equals) {
        this.warning("Optional probability should not equal 100%, otherwize create a Mandatory sequence instead ;)", 
          VideoGenPackage.Literals.OPTIONAL__PROBABILITY, 
          VideoGenValidator.INVALID_PROBABILITY);
      }
    }
  }
  
  @Check
  public void checkAlternativesProbability(final Alternatives alternatives) {
    int total = 0;
    Optional lastOption = null;
    EList<Optional> _options = alternatives.getOptions();
    for (final Optional option : _options) {
      {
        int _tal = total;
        int _probability = option.getProbability();
        total = (_tal + _probability);
        lastOption = option;
      }
    }
    if ((total > 100)) {
      this.error("Probabilities sum inside an Alternatives should not exceed 100%", 
        VideoGenPackage.Literals.ALTERNATIVES__OPTIONS, 
        VideoGenValidator.INVALID_PROBABILITY);
    }
  }
}
